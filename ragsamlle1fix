"""
Parallel RAG with Config-Only Labels
- Uses unique labels from your actual config patterns
- Auto-generates patterns with those same labels in new combinations
- Zero generic patterns
"""

import os
import re
import json
import logging
import threading
import queue
from typing import Dict, List, Set
from collections import defaultdict
from datetime import datetime
import pandas as pd

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# ============================================================================
# CONFIG LABEL EXTRACTOR
# ============================================================================

class ConfigLabelExtractor:
    """Extract all unique labels from your config patterns"""
    
    @staticmethod
    def extract_all_labels(pattern_manager) -> Dict[str, str]:
        """
        Extract all unique labels and their regex patterns from config
        
        Returns:
        {
            'TradeID': r'(?P<TradeID>\\d{7,8})',
            'Currency_1': r'(?P<Currency_1>[A-Z]{3})',
            'Notional_1': r'(?P<Notional_1>\\$?\\d+(?:,\\d{3})*)',
            ...
        }
        """
        unique_labels = {}
        
        # Get all patterns from config
        for entity_name in pattern_manager.get_all_entity_names():
            patterns = pattern_manager.get_patterns_for_entity(entity_name)
            
            for pattern_info in patterns:
                pattern_str = pattern_info.get('pattern', '')
                
                # Find all named groups in pattern
                named_group_pattern = r'\(\?P<(\w+)>([^)]+(?:\([^)]*\))*[^)]*)\)'
                
                for match in re.finditer(named_group_pattern, pattern_str):
                    label_name = match.group(1)
                    label_regex = match.group(2)
                    
                    # Store first occurrence of each label
                    if label_name not in unique_labels:
                        unique_labels[label_name] = label_regex
                        logger.info(f"Found label: {label_name} = {label_regex[:80]}")
        
        logger.info(f"Total unique labels from config: {len(unique_labels)}")
        return unique_labels


# ============================================================================
# BACKGROUND RAG PROCESSOR - Config Labels Only
# ============================================================================

class BackgroundRAGProcessor:
    """
    Runs RAG analysis using ONLY config labels
    Auto-generates patterns with same labels in different combinations
    """
    
    def __init__(self, pattern_manager, knowledge_base):
        self.pattern_manager = pattern_manager
        self.knowledge_base = knowledge_base
        
        # Extract ALL unique labels from config
        self.config_labels = ConfigLabelExtractor.extract_all_labels(pattern_manager)
        
        logger.info(f"RAG Processor initialized with {len(self.config_labels)} config labels:")
        for label_name in self.config_labels.keys():
            logger.info(f"  - {label_name}")
        
        # Queue for processing
        self.unseen_queue = queue.Queue()
        
        # Results storage
        self.unseen_data = defaultdict(list)
        self.processing_complete = threading.Event()
        
        # Background thread
        self.processor_thread = None
        self.is_running = False
    
    def start(self):
        """Start background processing thread"""
        if self.is_running:
            return
        
        self.is_running = True
        self.processing_complete.clear()
        
        self.processor_thread = threading.Thread(
            target=self._process_queue,
            daemon=True,
            name="RAG-Processor"
        )
        self.processor_thread.start()
        logger.info("Background RAG processor started")
    
    def add_unseen_text(self, entity_name: str, text: str):
        """Add unseen text for RAG processing (non-blocking)"""
        self.unseen_queue.put({
            'entity_name': entity_name,
            'text': text,
            'timestamp': datetime.now()
        })
    
    def _process_queue(self):
        """Background thread: process unseen texts using config labels"""
        logger.info("RAG processor thread running...")
        
        while self.is_running:
            try:
                item = self.unseen_queue.get(timeout=1.0)
                
                entity_name = item['entity_name']
                text = item['text']
                
                # Analyze using config labels only
                analysis = self._analyze_with_config_labels(text, entity_name)
                
                if analysis:
                    self.unseen_data[entity_name].append(analysis)
                
                self.unseen_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Error in RAG processor: {e}")
    
    def _analyze_with_config_labels(self, text: str, entity_name: str) -> Dict:
        """
        Analyze unseen text using ONLY config labels
        """
        analysis = {
            'text': text,
            'candidates': [],
            'suggested_patterns': []
        }
        
        # Try to match using each config label pattern
        candidates = self._extract_with_config_labels(text, entity_name)
        analysis['candidates'] = candidates
        
        # Generate pattern suggestions using same labels
        if candidates:
            candidate_values = [c['value'] for c in candidates]
            suggestions = self._generate_config_based_suggestions(entity_name, candidate_values, candidates)
            analysis['suggested_patterns'] = suggestions
        
        return analysis
    
    def _extract_with_config_labels(self, text: str, entity_name: str) -> List[Dict]:
        """
        Extract values using existing label patterns from config
        """
        candidates = []
        seen_values = set()
        
        logger.debug(f"Trying {len(self.config_labels)} config labels on text...")
        
        # Try each config label pattern
        for label_name, label_regex in self.config_labels.items():
            # Create a searchable pattern from the label regex
            search_pattern = f"(?P<{label_name}>{label_regex})"
            
            try:
                matches = re.finditer(search_pattern, text, re.IGNORECASE | re.MULTILINE)
                
                for match in matches:
                    value = match.group(label_name)
                    
                    if value and value.strip() and value not in seen_values:
                        candidates.append({
                            'value': value.strip(),
                            'label': label_name,
                            'label_regex': label_regex,
                            'method': 'config_label_pattern'
                        })
                        seen_values.add(value)
                        logger.debug(f"  ✓ Matched {label_name}: {value[:50]}")
            
            except Exception as e:
                logger.debug(f"Label {label_name} error: {e}")
        
        return candidates
    
    def _generate_config_based_suggestions(self, entity_name: str, examples: List[str], 
                                          candidates: List[Dict]) -> List[Dict]:
        """
        Generate pattern suggestions by:
        1. Finding similar patterns from RAG
        2. Creating new combinations of config labels
        """
        suggestions = []
        
        # Strategy 1: RAG similarity matching
        query = f"Entity: {entity_name}, examples: {', '.join(examples[:3])}"
        similar_patterns = self.knowledge_base.search_similar_patterns(query, top_k=5)
        
        for similar in similar_patterns:
            suggestions.append({
                'pattern': similar['pattern'][:150],
                'pattern_id': similar['pattern_id'],
                'similarity': similar['similarity_score'],
                'method': 'RAG_SIMILARITY',
                'reasoning': f"Similar to {similar['entity_name']} pattern"
            })
        
        # Strategy 2: Create new combinations of config labels
        detected_labels = set(c['label'] for c in candidates)
        
        if len(detected_labels) >= 2:
            # Suggest new pattern combining detected labels
            combined_pattern = self._create_combined_pattern(list(detected_labels))
            
            if combined_pattern:
                suggestions.append({
                    'pattern': combined_pattern,
                    'pattern_id': 'CONFIG_COMBINATION',
                    'similarity': 0.75,
                    'method': 'CONFIG_LABEL_COMBINATION',
                    'reasoning': f"New combination of config labels: {', '.join(detected_labels)}"
                })
        
        # Strategy 3: Generate pattern with detected labels in different order
        if len(detected_labels) >= 2:
            # Try alternative arrangement of same labels
            alt_pattern = self._create_alternative_label_pattern(list(detected_labels))
            
            if alt_pattern:
                suggestions.append({
                    'pattern': alt_pattern,
                    'pattern_id': 'CONFIG_REARRANGED',
                    'similarity': 0.70,
                    'method': 'CONFIG_LABEL_REARRANGEMENT',
                    'reasoning': f"Rearranged order of config labels: {', '.join(detected_labels)}"
                })
        
        return suggestions
    
    def _create_combined_pattern(self, labels: List[str]) -> str:
        """
        Combine detected labels into a new pattern
        Example: If we found TradeID and Currency, create pattern combining both
        """
        if not labels or len(labels) < 2:
            return None
        
        pattern_parts = []
        
        for label in labels[:3]:  # Combine up to 3 labels
            if label in self.config_labels:
                label_regex = self.config_labels[label]
                # Wrap in named group
                pattern_parts.append(f"(?P<{label}>{label_regex})")
        
        if len(pattern_parts) >= 2:
            # Join with flexible separator
            combined = r'.*?'.join(pattern_parts)
            return combined
        
        return None
    
    def _create_alternative_label_pattern(self, labels: List[str]) -> str:
        """
        Create alternative arrangement of same config labels
        Example: TradeID-Currency vs Currency-TradeID
        """
        if not labels or len(labels) < 2:
            return None
        
        # Reverse order
        reversed_labels = list(reversed(labels[:3]))
        
        pattern_parts = []
        for label in reversed_labels:
            if label in self.config_labels:
                label_regex = self.config_labels[label]
                pattern_parts.append(f"(?P<{label}>{label_regex})")
        
        if len(pattern_parts) >= 2:
            alternative = r'.*?'.join(pattern_parts)
            return alternative
        
        return None
    
    def stop_and_wait(self, timeout: float = 5.0):
        """Stop processor and wait for completion"""
        self.is_running = False
        
        # Wait for queue to empty
        self.unseen_queue.join()
        
        # Wait for thread
        if self.processor_thread:
            self.processor_thread.join(timeout=timeout)
        
        self.processing_complete.set()
        logger.info("RAG processor stopped")
    
    def get_results(self) -> Dict:
        """Get processed results"""
        return dict(self.unseen_data)
    
    def save_rag_report(self, output_path: str):
        """Save comprehensive RAG report"""
        logger.info(f"Generating RAG report: {output_path}")
        
        results = self.get_results()
        
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            
            # Sheet 1: Config Labels Library
            labels_data = []
            for label_name, label_regex in self.config_labels.items():
                labels_data.append({
                    'Label Name': label_name,
                    'Label Regex': label_regex[:120],
                    'Full Regex': label_regex
                })
            
            if labels_data:
                pd.DataFrame(labels_data).to_excel(writer, sheet_name='Config Labels', index=False)
            
            # Sheet 2: Unseen Texts Overview
            overview_data = []
            for entity, analyses in results.items():
                total_texts = len(analyses)
                total_candidates = sum(len(a['candidates']) for a in analyses)
                sample_values = []
                for a in analyses[:3]:
                    sample_values.extend([c['value'] for c in a['candidates'][:2]])
                
                overview_data.append({
                    'Entity': entity,
                    'Unseen Texts': total_texts,
                    'Total Candidates': total_candidates,
                    'Sample Values': ', '.join(sample_values[:5])
                })
            
            if overview_data:
                pd.DataFrame(overview_data).to_excel(writer, sheet_name='Unseen Overview', index=False)
            
            # Sheet 3: Candidate Details by Label
            candidate_data = []
            for entity, analyses in results.items():
                for analysis in analyses:
                    for candidate in analysis['candidates']:
                        candidate_data.append({
                            'Entity': entity,
                            'Value': candidate['value'],
                            'Config Label': candidate['label'],
                            'Label Regex': candidate['label_regex'][:80],
                            'Detection Method': candidate['method']
                        })
            
            if candidate_data:
                pd.DataFrame(candidate_data).to_excel(writer, sheet_name='Candidates', index=False)
            
            # Sheet 4: Pattern Suggestions (Using Config Labels)
            suggestion_data = []
            for entity, analyses in results.items():
                for analysis in analyses:
                    for suggestion in analysis['suggested_patterns']:
                        suggestion_data.append({
                            'Entity': entity,
                            'Suggested Pattern': suggestion['pattern'][:150],
                            'Method': suggestion['method'],
                            'Similarity': suggestion['similarity'],
                            'Reasoning': suggestion['reasoning']
                        })
            
            if suggestion_data:
                pd.DataFrame(suggestion_data).to_excel(writer, sheet_name='Suggestions', index=False)
            
            # Sheet 5: Summary
            summary_data = [
                {'Metric': 'Config Labels Available', 'Value': len(self.config_labels)},
                {'Metric': 'Entities Analyzed', 'Value': len(results)},
                {'Metric': 'Total Unseen Texts', 'Value': sum(len(analyses) for analyses in results.values())},
                {'Metric': 'Total Candidates Found', 'Value': sum(sum(len(a['candidates']) for a in analyses) for analyses in results.values())}
            ]
            
            pd.DataFrame(summary_data).to_excel(writer, sheet_name='Summary', index=False)
        
        logger.info(f"✓ RAG report saved: {output_path}")


# ============================================================================
# RAG ENABLED EXTRACTOR WRAPPER
# ============================================================================

class RAGEnabledExtractor:
    """Wrapper adding parallel RAG to existing extraction"""
    
    def __init__(self, pattern_manager, tracker):
        self.pattern_manager = pattern_manager
        self.tracker = tracker
        
        from offline_rag import OfflinePatternKnowledgeBase
        
        self.knowledge_base = OfflinePatternKnowledgeBase(pattern_manager.config_file)
        self.rag_processor = BackgroundRAGProcessor(pattern_manager, self.knowledge_base)
        
        # Start background processor
        self.rag_processor.start()
    
    def detect_unseen_and_queue(self, line: str, entity_name: str, result: Dict):
        """Queue unseen text for RAG processing (non-blocking)"""
        if not result.get('value'):
            # Queue for background processing - returns instantly
            self.rag_processor.add_unseen_text(entity_name, line)
            result['is_unseen'] = True
    
    def finish_and_generate_report(self, report_path: str = None):
        """Wait for RAG completion and generate report"""
        logger.info("Waiting for RAG analysis to complete...")
        self.rag_processor.stop_and_wait(timeout=10.0)
        
        if report_path:
            self.rag_processor.save_rag_report(report_path)
        
        return self.rag_processor.get_results()


# ============================================================================
# USAGE IN YOUR extract_entities FUNCTION
# ============================================================================

"""
INTEGRATION EXAMPLE:

# At top of class or module (initialize once)
rag_extractor = RAGEnabledExtractor(self.pattern_manager, self.usage_tracker)

# In your existing extract_entities loop:
for line in email_lines:
    for entity_name in entity_names:
        patterns = self.pattern_manager.get_patterns_for_entity(entity_name)
        
        result = {'value': None, 'pattern_id': None}
        
        # ... your existing extraction code ...
        for pattern_entry in patterns:
            # pattern matching logic
            if match:
                result['value'] = extracted_value
                result['pattern_id'] = pattern_id
                break
        
        # ADD THIS: Non-blocking RAG queue (one line!)
        rag_extractor.detect_unseen_and_queue(line, entity_name, result)
        
        results[entity_name] = result

# After extraction complete and CSV exported:
# Generate RAG report
print("Generating RAG report...")
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
rag_report_path = f"RAG_Pattern_Analysis_{timestamp}.xlsx"
rag_extractor.finish_and_generate_report(rag_report_path)
print(f"✓ RAG report: {rag_report_path}")
"""
