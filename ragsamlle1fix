"""
Enhanced candidate extraction that decomposes patterns into individual label regex
Example: "(?P<TradeID>\\d{7,8}).*(?P<Currency>[A-Z]{3})"
         → Extracts TradeID pattern: "(?P<TradeID>\\d{7,8})"
         → Extracts Currency pattern: "(?P<Currency>[A-Z]{3})"
"""

import os
import re
import json
import logging
from typing import Dict, List, Set, Tuple
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# ============================================================================
# LABEL PATTERN EXTRACTOR - Decompose Composite Patterns
# ============================================================================

class LabelPatternExtractor:
    """
    Extracts individual label patterns from composite regex patterns
    
    Example Input: "(?P<TradeID>\\d{7,8})[A-Za-z]+\\s+(?P<Currency_1>[A-Z]{3})"
    Example Output: {
        'TradeID': '(?P<TradeID>\\d{7,8})',
        'Currency_1': '(?P<Currency_1>[A-Z]{3})'
    }
    """
    
    @staticmethod
    def extract_label_patterns(composite_pattern: str) -> Dict[str, str]:
        """
        Extract individual labeled sub-patterns from composite pattern
        """
        label_patterns = {}
        
        # Pattern to find named groups with their content
        # Matches: (?P<LabelName>....) where .... is the capture group content
        named_group_regex = r'\(\?P<(\w+)>([^)]+(?:\([^)]*\))*[^)]*)\)'
        
        # Find all named groups
        matches = re.finditer(named_group_regex, composite_pattern)
        
        for match in matches:
            label_name = match.group(1)
            label_pattern_content = match.group(2)
            
            # Reconstruct as standalone pattern
            standalone_pattern = f"(?P<{label_name}>{label_pattern_content})"
            
            label_patterns[label_name] = standalone_pattern
        
        return label_patterns
    
    @staticmethod
    def extract_label_patterns_advanced(composite_pattern: str) -> Dict[str, str]:
        """
        Advanced extraction that handles nested groups and complex patterns
        """
        label_patterns = {}
        
        # Stack-based parsing for nested parentheses
        i = 0
        while i < len(composite_pattern):
            # Look for named group start
            if composite_pattern[i:i+3] == '(?P':
                # Extract label name
                label_start = i + 4  # After '(?P<'
                label_end = composite_pattern.find('>', label_start)
                if label_end == -1:
                    i += 1
                    continue
                
                label_name = composite_pattern[label_start:label_end]
                
                # Extract pattern content (handle nested parens)
                pattern_start = label_end + 1
                paren_count = 1
                j = pattern_start
                
                while j < len(composite_pattern) and paren_count > 0:
                    if composite_pattern[j] == '(' and (j == 0 or composite_pattern[j-1] != '\\'):
                        paren_count += 1
                    elif composite_pattern[j] == ')' and (j == 0 or composite_pattern[j-1] != '\\'):
                        paren_count -= 1
                    j += 1
                
                pattern_end = j - 1
                pattern_content = composite_pattern[pattern_start:pattern_end]
                
                # Create standalone pattern
                standalone_pattern = f"(?P<{label_name}>{pattern_content})"
                label_patterns[label_name] = standalone_pattern
                
                i = j
            else:
                i += 1
        
        return label_patterns


# ============================================================================
# ENHANCED UNSEEN PATTERN DETECTOR - Uses Individual Label Patterns
# ============================================================================

class SmartUnseenPatternDetector:
    """
    Smart detector that:
    1. Decomposes config patterns into individual label patterns
    2. Uses each label pattern independently for candidate extraction
    """
    
    def __init__(self, pattern_manager, knowledge_base):
        self.pattern_manager = pattern_manager
        self.knowledge_base = knowledge_base
        self.unseen_texts = defaultdict(list)
        
        # Build comprehensive label pattern library
        self.label_pattern_library = self._build_label_pattern_library()
    
    def _build_label_pattern_library(self) -> Dict[str, List[Dict]]:
        """
        Build library of individual label patterns from all config patterns
        
        Returns: {
            'TradeID': [
                {'pattern': '(?P<TradeID>\\d{7,8})', 'source_pattern_id': 'PKG_PTN001', ...},
                {'pattern': '(?P<TradeID>\\w{8})', 'source_pattern_id': 'PKG_PTN002', ...},
            ],
            'Currency_1': [...],
            ...
        }
        """
        library = defaultdict(list)
        extractor = LabelPatternExtractor()
        
        # Process all entities and patterns
        for entity_name in self.pattern_manager.get_all_entity_names():
            patterns = self.pattern_manager.get_patterns_for_entity(entity_name)
            
            for pattern_entry in patterns:
                composite_pattern = pattern_entry.get('pattern', '')
                pattern_id = pattern_entry.get('pattern_id', 'UNKNOWN')
                
                # Extract individual label patterns from composite
                label_patterns = extractor.extract_label_patterns_advanced(composite_pattern)
                
                # Add each label pattern to library
                for label_name, label_pattern in label_patterns.items():
                    library[label_name].append({
                        'label': label_name,
                        'pattern': label_pattern,
                        'source_pattern_id': pattern_id,
                        'source_entity': entity_name,
                        'original_composite': composite_pattern
                    })
        
        logger.info(f"Built label pattern library with {len(library)} unique labels")
        for label, patterns in library.items():
            logger.info(f"  Label '{label}': {len(patterns)} patterns")
        
        return library
    
    def detect_unseen(self, text: str, entity_name: str, extracted_result: Dict) -> bool:
        """Detect unseen patterns and extract candidates"""
        if not extracted_result.get('value'):
            candidates = self._extract_candidates_using_label_patterns(text, entity_name)
            
            if candidates:
                self.unseen_texts[entity_name].extend(candidates)
                return True
        
        return False
    
    def _extract_candidates_using_label_patterns(self, text: str, entity_name: str) -> List[Dict]:
        """
        Extract candidates using individual label patterns from library
        """
        candidates = []
        seen_values = set()
        
        # Get all labels that might be relevant for this entity
        relevant_labels = self._get_relevant_labels_for_entity(entity_name)
        
        logger.info(f"Extracting candidates for {entity_name} using labels: {relevant_labels}")
        
        # Try each label pattern
        for label in relevant_labels:
            if label not in self.label_pattern_library:
                continue
            
            label_pattern_list = self.label_pattern_library[label]
            
            # Try each pattern variation for this label
            for pattern_info in label_pattern_list:
                label_name = pattern_info['label']
                label_pattern = pattern_info['pattern']
                source_pattern_id = pattern_info['source_pattern_id']
                
                try:
                    # Apply the individual label pattern
                    matches = re.finditer(label_pattern, text, re.IGNORECASE | re.MULTILINE | re.DOTALL)
                    
                    for match in matches:
                        # Extract the named group
                        group_dict = match.groupdict()
                        value = group_dict.get(label_name)
                        
                        if value and value.strip() and value not in seen_values:
                            candidates.append({
                                'value': value.strip(),
                                'label': label_name,
                                'pattern_used': label_pattern,
                                'source_pattern_id': source_pattern_id,
                                'entity_name': entity_name,
                                'extraction_method': 'individual_label_pattern'
                            })
                            seen_values.add(value)
                            logger.info(f"  ✓ Found candidate for '{label_name}': {value[:50]}")
                
                except re.error as e:
                    logger.warning(f"Pattern error for label '{label_name}': {e}")
                except Exception as e:
                    logger.warning(f"Extraction error for label '{label_name}': {e}")
        
        logger.info(f"Total candidates extracted: {len(candidates)}")
        return candidates
    
    def _get_relevant_labels_for_entity(self, entity_name: str) -> List[str]:
        """
        Get list of labels that are relevant for an entity
        
        Strategy: Return all labels from patterns of this entity +
                  commonly related labels
        """
        relevant_labels = set()
        
        # Get labels from this entity's patterns
        patterns = self.pattern_manager.get_patterns_for_entity(entity_name)
        extractor = LabelPatternExtractor()
        
        for pattern_entry in patterns:
            composite_pattern = pattern_entry.get('pattern', '')
            label_patterns = extractor.extract_label_patterns_advanced(composite_pattern)
            relevant_labels.update(label_patterns.keys())
        
        # Add commonly related labels (from your config structure)
        common_related_labels = [
            'TradeID', 'Currency', 'Currency_1', 'Currency_2',
            'Notional_1', 'Status', 'Product', 'SubProduct',
            'MarketwireID', 'BusinessDate'
        ]
        
        # If entity is PackageDetails, include all trading labels
        if 'Package' in entity_name or 'Trade' in entity_name:
            relevant_labels.update(common_related_labels)
        
        return list(relevant_labels)
    
    def get_unseen_summary(self) -> Dict:
        """Get detailed summary of unseen patterns"""
        summary = {}
        
        for entity_name, candidate_list in self.unseen_texts.items():
            # Group by label
            by_label = defaultdict(lambda: {'values': [], 'patterns_used': set()})
            
            for candidate in candidate_list:
                if isinstance(candidate, dict):
                    label = candidate.get('label', 'UNKNOWN')
                    value = candidate.get('value', str(candidate))
                    pattern_used = candidate.get('pattern_used', 'N/A')
                    
                    by_label[label]['values'].append(value)
                    by_label[label]['patterns_used'].add(pattern_used)
            
            # Create summary
            summary[entity_name] = {
                'total_count': len(candidate_list),
                'by_label': {
                    label: {
                        'count': len(data['values']),
                        'examples': list(set(data['values']))[:10],
                        'pattern_count': len(data['patterns_used']),
                        'patterns_used': list(data['patterns_used'])[:3]
                    }
                    for label, data in by_label.items()
                }
            }
        
        return summary


# ============================================================================
# DEMO WITH DETAILED LOGGING
# ============================================================================

def demo_smart_candidate_extraction():
    """Demo with detailed extraction logging"""
    from pattern_tracking import PatternManager, PatternUsageTracker
    
    # Initialize
    pattern_manager = PatternManager("Pattern_Config.json")
    tracker = PatternUsageTracker()
    
    logger.info("="*80)
    logger.info("SMART CANDIDATE EXTRACTION - Using Individual Label Patterns")
    logger.info("="*80)
    
    # Build detector with label pattern library
    from offline_rag import OfflinePatternKnowledgeBase
    knowledge_base = OfflinePatternKnowledgeBase(pattern_manager.config_file)
    detector = SmartUnseenPatternDetector(pattern_manager, knowledge_base)
    
    # Show what patterns were extracted
    print("\n" + "="*80)
    print("LABEL PATTERN LIBRARY")
    print("="*80)
    for label, pattern_list in detector.label_pattern_library.items():
        print(f"\n{label} ({len(pattern_list)} patterns):")
        for i, p in enumerate(pattern_list[:2], 1):  # Show first 2
            print(f"  {i}. {p['pattern'][:80]}...")
            print(f"     Source: {p['source_pattern_id']}")
    
    # Test with sample text
    sample_text = """
    Trade Confirmation Details:
    Trade ID: 12345678A
    Currency: USD
    Secondary Currency: EUR
    Notional Amount: $100,000,000
    Status: Confirmed
    Product: Interest Rate Swap
    Sub-Product: Fixed-Float-Swap
    MarketwireID: MW2025110001
    Business Date: 11/10/2025
    
    Alternative Format Test:
    Deal Reference: XYZ-2025-11-001
    CCY1: GBP
    State: PENDING
    TradeAmount: 50000000
    """
    
    # Try extraction for PackageDetails
    entity_name = "PackageDetails"
    result = {'value': None}  # Simulating failed extraction
    
    print("\n" + "="*80)
    print(f"EXTRACTING CANDIDATES FOR: {entity_name}")
    print("="*80)
    
    detector.detect_unseen(sample_text, entity_name, result)
    
    # Show results
    unseen_summary = detector.get_unseen_summary()
    
    if entity_name in unseen_summary:
        entity_data = unseen_summary[entity_name]
        print(f"\nTotal Candidates Found: {entity_data['total_count']}")
        print("\nBy Label:")
        print("-" * 80)
        
        for label, label_data in entity_data['by_label'].items():
            print(f"\n{label}:")
            print(f"  Count: {label_data['count']}")
            print(f"  Examples: {label_data['examples']}")
            print(f"  Patterns Used: {label_data['pattern_count']}")
            if label_data['patterns_used']:
                print(f"  Sample Pattern: {label_data['patterns_used'][0][:80]}...")


if __name__ == "__main__":
    demo_smart_candidate_extraction()
