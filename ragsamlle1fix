"""
Complete Pattern Matcher for Unseen Detection
- Matches COMPLETE trading patterns from config
- Detects when entire line doesn't match ANY pattern
- Suggests closest matching pattern for unseen trades
"""

import re
import logging
from typing import Dict, List, Tuple
from collections import defaultdict

logger = logging.getLogger(__name__)


# ============================================================================
# PATTERN MATCHER - Match Complete Patterns
# ============================================================================

class CompletePatternMatcher:
    """
    Match complete trading patterns from config
    Detect unseen patterns that don't match any config pattern
    """
    
    def __init__(self, pattern_manager):
        self.pattern_manager = pattern_manager
        
        # Build complete patterns library
        self.complete_patterns = self._build_complete_patterns()
        logger.info(f"Loaded {len(self.complete_patterns)} complete patterns from config")
    
    def _build_complete_patterns(self) -> Dict[str, Dict]:
        """
        Build library of complete patterns from config
        
        Returns:
        {
            'PKG_PTN001': {
                'pattern': r'(?P<TradeID>\d{7,8}).*?(?P<Currency>[A-Z]{3})',
                'entity_name': 'PackageDetails',
                'labels': ['TradeID', 'Currency'],
                'pattern_id': 'PKG_PTN001'
            },
            ...
        }
        """
        patterns_library = {}
        
        for entity_name in self.pattern_manager.get_all_entity_names():
            patterns = self.pattern_manager.get_patterns_for_entity(entity_name)
            
            for pattern_info in patterns:
                pattern_id = pattern_info.get('pattern_id', 'UNKNOWN')
                pattern_str = pattern_info.get('pattern', '')
                
                if not pattern_str:
                    continue
                
                # Extract all labels from pattern
                labels = re.findall(r'\(\?P<(\w+)>', pattern_str)
                
                patterns_library[pattern_id] = {
                    'pattern': pattern_str,
                    'pattern_id': pattern_id,
                    'entity_name': entity_name,
                    'labels': labels,
                    'compiled': re.compile(pattern_str, re.IGNORECASE | re.MULTILINE | re.DOTALL)
                }
        
        return patterns_library
    
    def match_line_to_pattern(self, line: str) -> Dict:
        """
        Try to match a line to existing patterns
        
        Returns:
        {
            'matched': True/False,
            'pattern_id': 'PKG_PTN001' or None,
            'extracted_data': {label: value},
            'confidence': 0.0-1.0
        }
        """
        best_match = {
            'matched': False,
            'pattern_id': None,
            'extracted_data': {},
            'confidence': 0.0
        }
        
        # Try each complete pattern
        for pattern_id, pattern_info in self.complete_patterns.items():
            try:
                match = pattern_info['compiled'].search(line)
                
                if match:
                    # Extract all named groups
                    groupdict = match.groupdict()
                    
                    # Check how many labels were extracted
                    extracted_labels = sum(1 for v in groupdict.values() if v)
                    total_labels = len(pattern_info['labels'])
                    
                    # Confidence = ratio of extracted labels
                    confidence = extracted_labels / total_labels if total_labels > 0 else 0
                    
                    # Check if this is the best match
                    if confidence > best_match['confidence']:
                        best_match = {
                            'matched': True,
                            'pattern_id': pattern_id,
                            'extracted_data': groupdict,
                            'confidence': confidence
                        }
                
            except Exception as e:
                logger.debug(f"Pattern {pattern_id} error: {e}")
        
        return best_match
    
    def find_closest_patterns(self, line: str, top_k: int = 5) -> List[Dict]:
        """
        Find closest matching patterns using fuzzy matching
        For unseen lines, find which patterns are ALMOST matching
        """
        closest_patterns = []
        
        # Try partial matching using difflib
        from difflib import SequenceMatcher
        
        for pattern_id, pattern_info in self.complete_patterns.items():
            # Extract sample values from pattern description
            pattern_str = pattern_info['pattern']
            
            # Calculate similarity using sequence matching
            similarity = SequenceMatcher(None, line, pattern_str).ratio()
            
            closest_patterns.append({
                'pattern_id': pattern_id,
                'pattern': pattern_str,
                'entity_name': pattern_info['entity_name'],
                'similarity': similarity,
                'labels': pattern_info['labels']
            })
        
        # Sort by similarity and return top-k
        closest_patterns.sort(key=lambda x: x['similarity'], reverse=True)
        return closest_patterns[:top_k]


# ============================================================================
# UNSEEN PATTERN DETECTOR - Complete Pattern Based
# ============================================================================

class UnseenPatternDetector:
    """
    Detect unseen complete patterns
    Track lines that don't match any config pattern
    """
    
    def __init__(self, pattern_matcher, knowledge_base):
        self.pattern_matcher = pattern_matcher
        self.knowledge_base = knowledge_base
        
        # Store unseen patterns
        self.unseen_patterns = defaultdict(list)  # entity -> list of unseen lines
        self.pattern_suggestions = defaultdict(list)  # unseen_pattern -> suggested patterns
    
    def detect_unseen_line(self, line: str, entity_name: str) -> Dict:
        """
        Detect if a line is unseen (doesn't match any complete pattern)
        
        Returns:
        {
            'is_unseen': True/False,
            'best_match': {...},
            'closest_patterns': [...],
            'confidence': float
        }
        """
        result = {
            'line': line,
            'entity_name': entity_name,
            'is_unseen': False,
            'best_match': None,
            'closest_patterns': [],
            'confidence': 0.0
        }
        
        # Try to match against config patterns
        best_match = self.pattern_matcher.match_line_to_pattern(line)
        result['best_match'] = best_match
        result['confidence'] = best_match['confidence']
        
        # Consider as UNSEEN if:
        # 1. No pattern matched at all, OR
        # 2. Partial match but with LOW confidence (< 0.7)
        if not best_match['matched'] or best_match['confidence'] < 0.7:
            result['is_unseen'] = True
            
            # Store for later analysis
            self.unseen_patterns[entity_name].append({
                'line': line,
                'best_match': best_match,
                'timestamp': datetime.now()
            })
            
            # Find closest patterns for suggestion
            closest = self.pattern_matcher.find_closest_patterns(line, top_k=5)
            result['closest_patterns'] = closest
            
            logger.info(f"Unseen pattern detected for {entity_name}: {line[:60]}...")
            logger.info(f"  Closest patterns: {[p['pattern_id'] for p in closest[:3]]}")
        
        return result


# ============================================================================
# ENHANCED RAG PROCESSOR - Complete Pattern Detection
# ============================================================================

class EnhancedRAGProcessor(BackgroundRAGProcessor):
    """
    Enhanced RAG processor that tracks complete patterns
    Not individual labels
    """
    
    def __init__(self, pattern_manager, knowledge_base):
        super().__init__(pattern_manager, knowledge_base)
        
        # Initialize pattern matcher
        self.pattern_matcher = CompletePatternMatcher(pattern_manager)
        self.unseen_detector = UnseenPatternDetector(self.pattern_matcher, knowledge_base)
    
    def add_unseen_pattern(self, line: str, entity_name: str):
        """Queue complete unseen pattern for analysis"""
        if not line or not line.strip():
            return
        
        self.unseen_queue.put({
            'entity_name': entity_name,
            'text': line.strip(),
            'type': 'complete_pattern',
            'timestamp': datetime.now()
        })
    
    def _process_queue(self):
        """Background thread: process unseen COMPLETE patterns"""
        logger.info("RAG processor thread running...")
        processed_count = 0
        
        while self.is_running:
            try:
                item = self.unseen_queue.get(timeout=0.5)
                
                entity_name = item['entity_name']
                text = item['text']
                
                logger.debug(f"Processing complete pattern for {entity_name}")
                
                # Analyze as complete pattern
                analysis = self._analyze_complete_pattern(text, entity_name)
                
                if analysis:
                    self.unseen_data[entity_name].append(analysis)
                    processed_count += 1
                
                self.unseen_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Error in RAG processor: {e}", exc_info=True)
    
    def _analyze_complete_pattern(self, line: str, entity_name: str) -> Dict:
        """Analyze complete pattern and suggest closest matching patterns"""
        
        # Detect if unseen
        detection = self.unseen_detector.detect_unseen_line(line, entity_name)
        
        analysis = {
            'text': line,
            'entity_name': entity_name,
            'is_unseen': detection['is_unseen'],
            'best_match': detection['best_match'],
            'confidence': detection['confidence'],
            'closest_patterns': detection['closest_patterns'],
            'suggested_patterns': []
        }
        
        # If unseen, suggest patterns
        if detection['is_unseen']:
            suggestions = self._suggest_patterns_for_unseen(
                line,
                entity_name,
                detection['closest_patterns']
            )
            analysis['suggested_patterns'] = suggestions
        
        return analysis
    
    def _suggest_patterns_for_unseen(self, line: str, entity_name: str, 
                                     closest_patterns: List[Dict]) -> List[Dict]:
        """Suggest patterns for unseen complete patterns"""
        suggestions = []
        
        # Strategy 1: Suggest closest patterns from config
        for closest in closest_patterns[:3]:
            suggestions.append({
                'pattern': closest['pattern'][:150],
                'pattern_id': closest['pattern_id'],
                'entity_name': closest['entity_name'],
                'method': 'CLOSEST_CONFIG_PATTERN',
                'similarity': closest['similarity'],
                'labels': closest['labels'],
                'reasoning': f"Closest matching pattern (similarity: {closest['similarity']:.2%})",
                'tested_on_text': line[:120],
                'pattern_works': self._test_pattern(closest['pattern'], line),
            })
        
        # Strategy 2: RAG-based suggestions
        rag_suggestions = self.knowledge_base.search_similar_patterns(
            f"Entity: {entity_name}, example: {line[:100]}",
            top_k=3
        )
        
        for rag_result in rag_suggestions:
            suggestions.append({
                'pattern': rag_result['pattern'][:150],
                'pattern_id': rag_result['pattern_id'],
                'entity_name': rag_result.get('entity_name', 'N/A'),
                'method': 'RAG_SIMILARITY',
                'similarity': rag_result['similarity_score'],
                'labels': [],
                'reasoning': f"RAG-based suggestion (score: {rag_result['similarity_score']:.2%})",
                'tested_on_text': line[:120],
                'pattern_works': self._test_pattern(rag_result['pattern'], line),
            })
        
        return suggestions
    
    def _test_pattern(self, pattern: str, text: str) -> bool:
        """Test if pattern works on unseen text"""
        try:
            match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE | re.DOTALL)
            return match is not None
        except:
            return False


# ============================================================================
# INTEGRATION WITH extract_entities
# ============================================================================

def extract_entities(self):
    """Extract with complete pattern detection"""
    
    if self.selected_email is None:
        messagebox.showwarning("No Selection", "Please select an email")
        return
    
    try:
        entity_json = self.entity_text.get(1.0, tk.END).strip()
        self.entity_definitions = json.loads(entity_json)
    except json.JSONDecodeError as e:
        messagebox.showerror("JSON Error", f"Invalid JSON: {str(e)}")
        return
    
    try:
        self.clear_results()
        
        # Initialize enhanced RAG (only once)
        if not hasattr(self, 'rag_extractor') or self.rag_extractor is None:
            logger.info("Initializing Enhanced RAG processor...")
            self.rag_extractor = RAGEnabledExtractor(self.pattern_manager, self.usage_tracker)
        
        entity_names = self.pattern_manager.get_all_entity_names()
        email_data = self.selected_email
        results = {}
        entities = {}
        unseen_count = 0
        
        logger.info(f"Processing: {email_data['subject']}")
        
        # Process email body line by line
        email_lines = email_data['body'].splitlines()
        email_lines = list(filter(None, email_lines))
        
        for line in email_lines:
            line = line.strip()
            if not line:
                continue
            
            # ===== TRY TO MATCH COMPLETE PATTERN =====
            pattern_match = self.rag_extractor.rag_processor.pattern_matcher.match_line_to_pattern(line)
            
            if pattern_match['matched'] and pattern_match['confidence'] >= 0.7:
                # ✓ Line matches a complete pattern from config
                logger.info(f"✓ Matched pattern {pattern_match['pattern_id']}: {line[:50]}")
                
                # Extract data
                for k, v in pattern_match['extracted_data'].items():
                    if v:
                        entities.setdefault(k, []).append(f"{v}")
                
            else:
                # ✗ Line is UNSEEN - doesn't match any complete pattern
                logger.info(f"✗ Unseen pattern: {line[:50]}...")
                unseen_count += 1
                
                # Queue for RAG analysis
                self.rag_extractor.rag_processor.add_unseen_pattern(line, "PackageDetails")
        
        # Display results
        self.entity_result_text.delete(1.0, tk.END)
        if entities:
            for k, vals in entities.items():
                self.entity_result_text.insert(tk.END, f"{k}: {', '.join(vals)}\n")
        else:
            self.entity_result_text.insert(tk.END, "No matching patterns found")
        
        logger.info(f"Complete extraction. Unseen patterns: {unseen_count}")
        
        # Generate RAG report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        rag_report_path = f"RAG_Pattern_Analysis_{timestamp}.xlsx"
        
        rag_results = self.rag_extractor.finish_and_generate_report(rag_report_path)
        messagebox.showinfo("Success", f"Complete!\nReport: {rag_report_path}")
    
    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        messagebox.showerror("Error", f"Failed: {str(e)}")
