# streamlit_email_app.py
"""
Streamlit UI wrapper for existing Email Extraction functionality
Keeps all your existing backend code - just replaces Tkinter UI
"""

import streamlit as st
import pandas as pd
import json
import os
import glob
from datetime import datetime
from pathlib import Path
import sys

# Import your existing classes (adjust paths as needed)
from your_existing_code import (
    EmailExtractorApp,  # Your main Tkinter app class
    PatternManager,
    UsageTracker,
    EmailCleaner,
    RAGEnabledExtractor
    # ... import other classes you need
)

# Page config
st.set_page_config(
    page_title="Email Entity Extractor",
    page_icon="üìß",
    layout="wide"
)


# ============================================================================
# SESSION STATE INITIALIZATION
# ============================================================================

def init_session_state():
    """Initialize session state to store app instance and data"""
    if 'app' not in st.session_state:
        # Create instance of your existing app class (without Tkinter UI)
        st.session_state.app = create_app_instance()
    
    if 'selected_email' not in st.session_state:
        st.session_state.selected_email = None
    
    if 'email_chain' not in st.session_state:
        st.session_state.email_chain = []
    
    if 'extraction_results' not in st.session_state:
        st.session_state.extraction_results = None


def create_app_instance():
    """
    Create your existing app instance without Tkinter
    Modify your class to work without tk.Tk()
    """
    # Your existing initialization logic
    app = EmailExtractorBackend()  # Backend-only version
    return app


# ============================================================================
# BACKEND CLASS (Modified from your Tkinter app)
# ============================================================================

class EmailExtractorBackend:
    """
    Your existing EmailExtractorApp class modified to work without Tkinter
    Remove all tk.* references, keep all business logic
    """
    
    def __init__(self):
        """Initialize without Tkinter components"""
        # Your existing initialization
        self.temp_path = "./temp"
        self.out_path = "./output"
        self.email_username = ""
        
        # Create directories
        Path(self.temp_path).mkdir(exist_ok=True)
        Path(self.out_path).mkdir(exist_ok=True)
        
        # Initialize your managers
        self.pattern_manager = PatternManager()
        self.usage_tracker = UsageTracker()
        self.email_cleaner = EmailCleaner()
        self.rag_extractor = None
        
        # Activity keywords
        self.activity_keywords = ["BOOKED", "CANCELLED", "AMENDED", "CONFIRMED"]
        
        # Static headers for export
        self.static_headers = [
            'Trade_ID', 'Email_Date', 'Email_From', 'Email_Subject',
            # ... rest of your headers
        ]
        
        self.selected_email = None
        self.entity_definitions = {}
    
    # ===== KEEP ALL YOUR EXISTING METHODS =====
    # Just remove tk.messagebox and replace with return values/exceptions
    
    def fetch_emails_from_outlook(self, days_back=7):
        """Your existing email fetch logic"""
        # Return emails instead of updating treeview
        try:
            # Your existing Outlook logic
            emails = []  # populated by your code
            return {'success': True, 'emails': emails}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def extract_and_export(self):
        """Your existing extraction logic - returns results instead of showing messagebox"""
        try:
            # ALL YOUR EXISTING EXTRACTION CODE
            # ... (keep everything the same)
            
            # Instead of messagebox.showinfo, return results
            return {
                'success': True,
                'records': len(entity_df),
                'dataframe': entity_df,
                'stats': {
                    'matched': matched_count,
                    'unseen': unseen_count,
                    'tables': len(all_tables)
                }
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def export_consolidated_results(self):
        """Your existing consolidation logic"""
        try:
            # ALL YOUR EXISTING CONSOLIDATION CODE
            return {
                'success': True,
                'file': consolidated_file,
                'records': len(df_combined)
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}


# ============================================================================
# STREAMLIT UI
# ============================================================================

def main():
    """Main Streamlit app"""
    
    init_session_state()
    app = st.session_state.app
    
    # Header
    st.title("üìß Email Entity Extractor")
    st.markdown("---")
    
    # Sidebar - Configuration (replaces your Tkinter config panel)
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Email Credentials
        st.subheader("üìß Email Settings")
        app.email_username = st.text_input("Email Address", value=app.email_username)
        days_back = st.number_input("Days to Fetch", min_value=1, max_value=30, value=7)
        
        # Paths
        st.subheader("üìÅ Paths")
        app.temp_path = st.text_input("Temp Path", value=app.temp_path)
        app.out_path = st.text_input("Output Path", value=app.out_path)
        
        # Activity Keywords
        st.subheader("üè∑Ô∏è Activity Keywords")
        keywords_text = st.text_area(
            "Keywords (one per line)",
            value="\n".join(app.activity_keywords),
            height=150
        )
        app.activity_keywords = [k.strip() for k in keywords_text.split('\n') if k.strip()]
        
        # Entity JSON
        st.subheader("üìã Entity Definitions")
        entity_json = st.text_area(
            "Entity JSON",
            value=json.dumps(app.entity_definitions, indent=2) if app.entity_definitions else "{}",
            height=200
        )
        
        if st.button("üíæ Save Config", type="primary"):
            try:
                app.entity_definitions = json.loads(entity_json)
                st.success("‚úÖ Configuration saved!")
            except json.JSONDecodeError as e:
                st.error(f"‚ùå Invalid JSON: {str(e)}")
    
    # Main content tabs (replaces your Tkinter tabs)
    tab1, tab2, tab3, tab4 = st.tabs([
        "üì® Email Fetch", 
        "üîç Extract & Export", 
        "üìä Consolidate", 
        "üìà Analytics"
    ])
    
    # ========== TAB 1: EMAIL FETCH (replaces your fetch_emails) ==========
    with tab1:
        st.header("üì® Fetch Emails from Outlook")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            st.info(f"üìß Email: {app.email_username or 'Not set'}")
            st.info(f"üìÖ Days: {days_back}")
        
        with col2:
            if st.button("üîÑ Fetch Emails", type="primary", use_container_width=True):
                if not app.email_username:
                    st.error("‚ùå Please set email address in sidebar")
                else:
                    with st.spinner("üîÑ Fetching emails from Outlook..."):
                        result = app.fetch_emails_from_outlook(days_back)
                    
                    if result['success']:
                        st.session_state.email_chain = result['emails']
                        st.success(f"‚úÖ Fetched {len(result['emails'])} emails")
                    else:
                        st.error(f"‚ùå Error: {result['error']}")
        
        # Display fetched emails (replaces your Treeview)
        if st.session_state.email_chain:
            st.markdown("---")
            st.subheader(f"üìß Email Chain ({len(st.session_state.email_chain)} emails)")
            
            # Create DataFrame for display
            email_display = pd.DataFrame([
                {
                    'Trade ID': email.get('trade_id', ''),
                    'Date': email.get('date', ''),
                    'From': email.get('sender', ''),
                    'Subject': email.get('subject', '')[:50] + '...' if len(email.get('subject', '')) > 50 else email.get('subject', '')
                }
                for email in st.session_state.email_chain
            ])
            
            # Selection
            selected_idx = st.selectbox(
                "Select email to process",
                range(len(st.session_state.email_chain)),
                format_func=lambda i: f"{i+1}. {st.session_state.email_chain[i].get('subject', 'No subject')}"
            )
            
            if st.button("‚úÖ Select This Email"):
                app.selected_email = st.session_state.email_chain[selected_idx]
                st.session_state.selected_email = app.selected_email
                st.success(f"‚úÖ Selected: {app.selected_email.get('subject', 'No subject')}")
            
            # Display table
            st.dataframe(email_display, use_container_width=True)
            
            # Show selected email details
            if st.session_state.selected_email:
                with st.expander("üìß Selected Email Details"):
                    email = st.session_state.selected_email
                    st.markdown(f"**Trade ID:** {email.get('trade_id', 'N/A')}")
                    st.markdown(f"**Date:** {email.get('date', 'N/A')}")
                    st.markdown(f"**From:** {email.get('sender', 'N/A')}")
                    st.markdown(f"**Subject:** {email.get('subject', 'N/A')}")
                    
                    st.markdown("**Body Preview:**")
                    st.text_area("Email Body", value=email.get('body', '')[:500], height=200, disabled=True)
    
    # ========== TAB 2: EXTRACT & EXPORT (replaces your extract button) ==========
    with tab2:
        st.header("üîç Extract & Export")
        
        if not st.session_state.selected_email:
            st.warning("‚ö†Ô∏è Please select an email from the 'Email Fetch' tab first")
        else:
            email = st.session_state.selected_email
            
            # Show selected email info
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üìã Trade ID", email.get('trade_id', 'N/A'))
            with col2:
                st.metric("üìÖ Date", email.get('date', 'N/A'))
            with col3:
                st.metric("üìß From", email.get('sender', 'N/A')[:20] + '...' if len(email.get('sender', '')) > 20 else email.get('sender', 'N/A'))
            
            st.markdown("---")
            
            # Extract button (replaces your Tkinter button)
            col1, col2, col3 = st.columns([1, 2, 1])
            
            with col2:
                if st.button("üöÄ Extract Entities", type="primary", use_container_width=True):
                    with st.spinner("üîÑ Extracting entities from email..."):
                        result = app.extract_and_export()
                    
                    if result['success']:
                        st.session_state.extraction_results = result
                        st.success(f"‚úÖ Extracted {result['records']} records!")
                        st.balloons()
                    else:
                        st.error(f"‚ùå Extraction failed: {result['error']}")
            
            # Show extraction results
            if st.session_state.extraction_results:
                st.markdown("---")
                result = st.session_state.extraction_results
                
                # Metrics
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("üìù Total Records", result['records'])
                with col2:
                    st.metric("‚úÖ Matched", result['stats']['matched'])
                with col3:
                    st.metric("‚ö†Ô∏è Unseen", result['stats']['unseen'])
                with col4:
                    st.metric("üìä Tables", result['stats']['tables'])
                
                # Dataframe display
                st.subheader("üìã Extracted Data")
                df = result['dataframe']
                
                if not df.empty:
                    # Add filters
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        methods = ['All'] + list(df['Extraction_Method'].unique()) if 'Extraction_Method' in df.columns else ['All']
                        method_filter = st.selectbox("Filter by Method", methods)
                    
                    with col2:
                        sources = ['All'] + list(df['Source'].unique()) if 'Source' in df.columns else ['All']
                        source_filter = st.selectbox("Filter by Source", sources)
                    
                    # Apply filters
                    filtered_df = df.copy()
                    if method_filter != 'All':
                        filtered_df = filtered_df[filtered_df['Extraction_Method'] == method_filter]
                    if source_filter != 'All':
                        filtered_df = filtered_df[filtered_df['Source'] == source_filter]
                    
                    st.markdown(f"**Showing {len(filtered_df)} of {len(df)} records**")
                    st.dataframe(filtered_df, use_container_width=True, height=400)
                    
                    # Download button
                    csv = filtered_df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="üì• Download CSV",
                        data=csv,
                        file_name=f"{email.get('trade_id', 'extraction')}.csv",
                        mime="text/csv"
                    )
                else:
                    st.info("‚ÑπÔ∏è No records extracted")
    
    # ========== TAB 3: CONSOLIDATE (replaces your consolidate button) ==========
    with tab3:
        st.header("üìä Consolidate Results")
        
        # Show temp files
        csv_files = glob.glob(f"{app.temp_path}/*.csv")
        
        st.info(f"üìÅ Found {len(csv_files)} CSV files in temp folder")
        
        if csv_files:
            # Show files
            with st.expander("üìÑ Files to Consolidate"):
                for file in csv_files:
                    st.text(f"‚Ä¢ {os.path.basename(file)}")
            
            st.markdown("---")
            
            # Consolidate button
            col1, col2, col3 = st.columns([1, 2, 1])
            
            with col2:
                if st.button("üìä Consolidate All Files", type="primary", use_container_width=True):
                    with st.spinner("üîÑ Consolidating files..."):
                        result = app.export_consolidated_results()
                    
                    if result['success']:
                        st.success(f"‚úÖ Consolidated {result['records']} records!")
                        st.info(f"üìÅ Output: {result['file']}")
                        
                        # Show download button
                        if os.path.exists(result['file']):
                            with open(result['file'], 'rb') as f:
                                st.download_button(
                                    label="üì• Download Consolidated Excel",
                                    data=f,
                                    file_name=os.path.basename(result['file']),
                                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                )
                    else:
                        st.error(f"‚ùå Consolidation failed: {result['error']}")
        else:
            st.warning("‚ö†Ô∏è No CSV files found in temp folder. Extract some emails first!")
    
    # ========== TAB 4: ANALYTICS ==========
    with tab4:
        st.header("üìà Analytics & Statistics")
        
        if st.session_state.extraction_results:
            result = st.session_state.extraction_results
            df = result['dataframe']
            
            if not df.empty:
                # Visualizations
                col1, col2 = st.columns(2)
                
                with col1:
                    if 'Extraction_Method' in df.columns:
                        method_counts = df['Extraction_Method'].value_counts()
                        st.bar_chart(method_counts)
                        st.caption("Extraction Methods Distribution")
                
                with col2:
                    if 'Source' in df.columns:
                        source_counts = df['Source'].value_counts()
                        st.bar_chart(source_counts)
                        st.caption("Records by Source")
                
                # Entity coverage
                st.subheader("üìä Entity Coverage")
                metadata_cols = ['Trade_ID', 'Email_Date', 'Email_From', 'Email_Subject',
                               'Conversation_ID', 'Package_ID', 'ActivityType', 'Pattern_ID',
                               'Source', 'Source_Line', 'Line_Index', 'Extraction_Method']
                entity_cols = [col for col in df.columns if col not in metadata_cols]
                
                if entity_cols:
                    coverage = []
                    for col in entity_cols:
                        non_null = df[col].notna().sum()
                        coverage.append({
                            'Entity': col,
                            'Count': non_null,
                            'Coverage %': (non_null / len(df)) * 100
                        })
                    
                    coverage_df = pd.DataFrame(coverage).sort_values('Coverage %', ascending=False)
                    st.dataframe(coverage_df, use_container_width=True)
            else:
                st.info("‚ÑπÔ∏è No data to analyze")
        else:
            st.info("‚ÑπÔ∏è Extract entities first to see analytics")


# ============================================================================
# RUN APP
# ============================================================================

if __name__ == "__main__":
    main()
