# streamlit_outlook_harvester_full.py
"""
Complete Streamlit version with:
- Multi-select email grid
- Integration with existing extract_and_export functions
- Consolidation functionality
- Results display
"""

import streamlit as st
import pandas as pd
import os
import re
import gc
import logging
from datetime import datetime, timedelta
import win32com.client
import pythoncom
import locale
from io import BytesIO
import json

# Import your existing extraction classes (adjust path as needed)
# from your_extraction_module import (
#     PatternManager, UsageTracker, EmailCleaner, 
#     RAGEnabledExtractor, extract_and_export, export_consolidated_results
# )

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Page config
st.set_page_config(
    page_title="Outlook Email Harvester & Extractor",
    page_icon="üìß",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        padding: 1rem 0;
    }
    .stButton>button {
        width: 100%;
    }
    .email-selected {
        background-color: #e3f2fd;
    }
</style>
""", unsafe_allow_html=True)


# ============================================================================
# SESSION STATE INITIALIZATION
# ============================================================================

def init_session_state():
    """Initialize session state variables"""
    if 'emails' not in st.session_state:
        st.session_state.emails = []
    if 'selected_emails' not in st.session_state:
        st.session_state.selected_emails = []  # List of indices
    if 'extraction_results' not in st.session_state:
        st.session_state.extraction_results = {}
    if 'consolidated_file' not in st.session_state:
        st.session_state.consolidated_file = None
    if 'entity_definitions' not in st.session_state:
        st.session_state.entity_definitions = {}
    if 'temp_path' not in st.session_state:
        st.session_state.temp_path = "./temp"
    if 'out_path' not in st.session_state:
        st.session_state.out_path = "./output"


# ============================================================================
# BACKEND CLASS (Your existing Outlook functions)
# ============================================================================

class OutlookEmailHarvesterBackend:
    """Backend class with all your existing Outlook functions"""
    
    def __init__(self):
        self.mailbox_folders = {
           
        }
    
    def connect_to_outlook(self, mailbox_name, folder_name):
        """Your existing connect_to_outlook function"""
        try:
            outlook = win32com.client.Dispatch("Outlook.Application")
            mapi = outlook.GetNamespace("MAPI")
            
            mailbox = None
            for i in range(1, mapi.Folders.Count + 1):
                m = mapi.Folders.Item(i)
                if m.Name == mailbox_name:
                    mailbox = m
                    break
            
            if mailbox is None:
                return None
            
            folder = None
            for j in range(1, mailbox.Folders.Count + 1):
                f = mailbox.Folders.Item(j)
                if f.Name == folder_name:
                    folder = f
                    break
            
            return folder
        except Exception as e:
            logger.error(f"Failed to connect to Outlook: {e}")
            return None
    
    def get_region_datefmt_ampm(self):
        """Your existing function"""
        region = locale.getdefaultlocale()[0] if locale.getdefaultlocale() else ''
        region_datefmt = {
            'en_US': ('%m/%d/%Y', True),
            'en_GB': ('%d/%m/%Y', False),
            'en_IN': ('%d-%m-%Y', False),
            'fr_FR': ('%d/%m/%Y', False),
            'de_DE': ('%d.%m.%Y', False),
            'es_ES': ('%d/%m/%Y', False),
            'en_UK': ('%d/%m/%Y', False),
            'en_HK': ('%d/%m/%Y', True)
        }
        return region_datefmt.get(region, ('%m/%d/%Y', True))
    
    def restrict_datetime_strings(self, date_dt, date_fmt, use_ampm):
        """Your existing function"""
        if use_ampm:
            am_marker = date_dt.replace(hour=1).strftime('%p')
            pm_marker = date_dt.replace(hour=13).strftime('%p')
            start_time = f"{date_dt.strftime(date_fmt)} 12:00:00 {am_marker}"
            end_time = f"{date_dt.strftime(date_fmt)} 11:59:59 {pm_marker}"
        else:
            start_time = f"{date_dt.strftime(date_fmt)} 00:00:00"
            end_time = f"{date_dt.strftime(date_fmt)} 23:59:59"
        return start_time, end_time
    
    def safe_items_to_list(self, items):
        """Your existing function"""
        try:
            return list(items)
        except Exception:
            if items is None:
                return []
            try:
                if getattr(items, "Subject", None) is not None:
                    return [items]
            except Exception:
                pass
            return []
    
    def process_items_in_batches(self, items, batch_size=150):
        """Your existing function"""
        items_list = self.safe_items_to_list(items)
        if not items_list:
            return []
        all_data = []
        for i in range(0, len(items_list), batch_size):
            batch = items_list[i:i + batch_size]
            for item in batch:
                try:
                    if getattr(item, "Class", None) == 43:
                        all_data.append({"item": item})
                except Exception as e:
                    logger.warning(f"Error reading batch mail: {e}")
                finally:
                    del item
            gc.collect()
        return all_data
    
    def extract_emails(self, mailbox_name, folder_name, trade_ids, days_back=3):
        """Your existing extraction logic"""
        pythoncom.CoInitialize()
        try:
            folder = self.connect_to_outlook(mailbox_name, folder_name)
            if not folder:
                return {'success': False, 'error': 'Could not connect to folder'}
            
            trade_ids_list = [tid.strip() for tid in re.split(",|\\s", trade_ids) if tid.strip()]
            today = datetime.now()
            date_fmt, use_ampm = self.get_region_datefmt_ampm()
            all_items = []

            for days_ago in range(1, days_back + 1):
                d = today - timedelta(days=days_ago)
                start_time, end_time = self.restrict_datetime_strings(d, date_fmt, use_ampm)
                filter_str = f"[ReceivedTime] >= '{start_time}' AND [ReceivedTime] <= '{end_time}'"
                items = folder.Items.Restrict(filter_str)
                items_list = self.process_items_in_batches(items, batch_size=150)
                
                if not items_list and use_ampm:
                    am_l = d.replace(hour=1).strftime('%p').lower()
                    pm_l = d.replace(hour=13).strftime('%p').lower()
                    start_time_l = f"{d.strftime(date_fmt)} 12:00:00 {am_l}"
                    end_time_l = f"{d.strftime(date_fmt)} 11:59:59 {pm_l}"
                    filter_str_l = f"[ReceivedTime] >= '{start_time_l}' AND [ReceivedTime] <= '{end_time_l}'"
                    items = folder.Items.Restrict(filter_str_l)
                    items_list = self.process_items_in_batches(items, batch_size=150)
                
                if items_list:
                    all_items.extend([entry["item"] for entry in items_list])

            emails = []
            for trade_id in trade_ids_list:
                for item in all_items:
                    try:
                        if getattr(item, "Class", None) == 43:
                            subject = item.Subject or ""
                            body = item.Body or ""
                            html_body = ""
                            try:
                                html_body = item.HTMLBody
                            except Exception:
                                pass
                            if (trade_id in subject or trade_id in body or (html_body and trade_id in html_body)):
                                emails.append({
                                    'trade_id': trade_id,
                                    'subject': subject,
                                    'sender': getattr(item, "SenderName", ""),
                                    'recipient': getattr(item, "To", ""),
                                    'date': item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S") if item.ReceivedTime else "",
                                    'body': body,
                                    'html_body': html_body,
                                })
                    except Exception:
                        pass

            gc.collect()
            return {'success': True, 'emails': emails}
        except Exception as e:
            gc.collect()
            return {'success': False, 'error': str(e)}
        finally:
            pythoncom.CoUninitialize()


# ============================================================================
# EXTRACTION INTEGRATION (Your existing extract_and_export logic)
# ============================================================================

class ExtractionBackend:
    """
    Wrapper for your existing extraction functions
    Replace with your actual import
    """
    
    def __init__(self, temp_path, out_path):
        self.temp_path = temp_path
        self.out_path = out_path
        # Initialize your pattern manager, usage tracker, etc.
        # self.pattern_manager = PatternManager()
        # self.usage_tracker = UsageTracker()
        # ... etc
    
    def extract_and_export(self, email_data, entity_definitions):
        """
        Your existing extract_and_export function
        Returns extraction results
        """
        try:
            # YOUR EXISTING EXTRACTION LOGIC HERE
            # This is where you call your actual extraction code
            
            # Placeholder - replace with your actual code
            results = {
                'success': True,
                'records': 0,  # Number of records extracted
                'dataframe': pd.DataFrame(),  # Extracted data
                'stats': {
                    'matched': 0,
                    'unseen': 0,
                    'tables': 0,
                    'conversations': 0,
                    'packages': 0
                }
            }
            
            return results
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def export_consolidated_results(self):
        """
        Your existing consolidation function
        """
        try:
            # YOUR EXISTING CONSOLIDATION LOGIC HERE
            
            # Placeholder - replace with your actual code
            consolidated_file = f"{self.out_path}/consolidated_report.xlsx"
            
            return {
                'success': True,
                'file': consolidated_file,
                'records': 0
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}


# ============================================================================
# STREAMLIT UI
# ============================================================================

def main():
    """Main Streamlit app"""
    
    init_session_state()
    
    # Create backend instances
    if 'outlook_backend' not in st.session_state:
        st.session_state.outlook_backend = OutlookEmailHarvesterBackend()
    
    if 'extraction_backend' not in st.session_state:
        st.session_state.extraction_backend = ExtractionBackend(
            st.session_state.temp_path,
            st.session_state.out_path
        )
    
    outlook_backend = st.session_state.outlook_backend
    extraction_backend = st.session_state.extraction_backend
    
    # Header
    st.markdown('<div class="main-header">üìß Outlook Email Harvester & Entity Extractor</div>', 
                unsafe_allow_html=True)
    st.markdown("---")
    
    # ========== SIDEBAR - CONFIGURATION ==========
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Mailbox Selection
        st.subheader("üì¨ Mailbox Selection")
        selected_mailbox = st.selectbox(
            "Select Mailbox",
            options=list(outlook_backend.mailbox_folders.keys()),
            index=0
        )
        
        # Folder Selection
        st.subheader("üìÅ Folder Selection")
        available_folders = outlook_backend.mailbox_folders.get(selected_mailbox, [])
        selected_folder = st.selectbox(
            "Select Outlook Folder",
            options=available_folders,
            index=0 if available_folders else None
        )
        
        # Days Back
        st.subheader("üìÖ Date Range")
        days_back = st.number_input(
            "Days to Search Back",
            min_value=1,
            max_value=30,
            value=3
        )
        
        # Paths
        st.markdown("---")
        st.subheader("üìÅ Paths")
        st.session_state.temp_path = st.text_input("Temp Path", value=st.session_state.temp_path)
        st.session_state.out_path = st.text_input("Output Path", value=st.session_state.out_path)
        
        # Entity Definitions
        st.markdown("---")
        st.subheader("üìã Entity Definitions")
        entity_json = st.text_area(
            "Entity JSON",
            value=json.dumps(st.session_state.entity_definitions, indent=2) if st.session_state.entity_definitions else "{}",
            height=200
        )
        
        if st.button("üíæ Save Config"):
            try:
                st.session_state.entity_definitions = json.loads(entity_json)
                st.success("‚úÖ Config saved!")
            except json.JSONDecodeError as e:
                st.error(f"‚ùå Invalid JSON: {str(e)}")
    
    # ========== MAIN CONTENT TABS ==========
    tab1, tab2, tab3, tab4 = st.tabs([
        "üì® Fetch Emails", 
        "üîç Extract & Export", 
        "üìä Consolidated Results",
        "üìà Analytics"
    ])
    
    # ========== TAB 1: FETCH EMAILS ==========
    with tab1:
        st.header("üì® Fetch Emails from Outlook")
        
        # Trade IDs Input
        col1, col2 = st.columns([3, 1])
        
        with col1:
            trade_ids_manual = st.text_area(
                "Enter Trade IDs (comma or space separated)",
                height=100,
                placeholder="Enter trade IDs...",
                key='trade_ids_input'
            )
        
        with col2:
            st.markdown("**OR Upload File**")
            uploaded_file = st.file_uploader(
                "Upload CSV/TXT",
                type=['csv', 'txt'],
                key='trade_file'
            )
            
            if uploaded_file:
                try:
                    content = uploaded_file.read().decode('utf-8')
                    trade_ids_from_file = re.findall(r'\b\w+\b', content)
                    st.success(f"‚úÖ Loaded {len(trade_ids_from_file)} IDs")
                    
                    if not trade_ids_manual:
                        trade_ids_manual = ", ".join(trade_ids_from_file)
                except Exception as e:
                    st.error(f"‚ùå Error: {str(e)}")
        
        final_trade_ids = trade_ids_manual.strip()
        
        st.markdown("---")
        
        # Fetch Button
        col1, col2, col3 = st.columns([1, 1, 2])
        
        with col1:
            if st.button("üîç Fetch Emails", type="primary", use_container_width=True):
                if not final_trade_ids:
                    st.error("‚ùå Please enter trade IDs")
                else:
                    with st.spinner("üîÑ Fetching emails..."):
                        result = outlook_backend.extract_emails(
                            selected_mailbox,
                            selected_folder,
                            final_trade_ids,
                            days_back
                        )
                    
                    if result['success']:
                        st.session_state.emails = result['emails']
                        st.session_state.selected_emails = []  # Reset selection
                        st.success(f"‚úÖ Fetched {len(result['emails'])} emails!")
                        st.balloons()
                    else:
                        st.error(f"‚ùå Failed: {result['error']}")
        
        with col2:
            if st.button("üóëÔ∏è Clear", use_container_width=True):
                st.session_state.emails = []
                st.session_state.selected_emails = []
                st.success("‚úÖ Cleared")
                st.rerun()
        
        # ========== EMAIL GRID WITH MULTI-SELECT ==========
        if st.session_state.emails:
            st.markdown("---")
            st.header(f"üìß Email Chain ({len(st.session_state.emails)} emails)")
            
            # Create display DataFrame
            email_display_data = []
            for idx, email in enumerate(st.session_state.emails):
                email_type = "Original"
                subj = email['subject'].lower()
                if "re:" in subj:
                    email_type = f"Reply {idx}"
                elif "fw:" in subj or "fwd:" in subj:
                    email_type = f"Forward {idx}"
                
                email_display_data.append({
                    'Select': False,  # Checkbox column
                    'Index': idx,
                    'Trade ID': email['trade_id'],
                    'Subject': email['subject'][:50] + "..." if len(email['subject']) > 50 else email['subject'],
                    'From': email['sender'][:30] + "..." if len(email['sender']) > 30 else email['sender'],
                    'To': email['recipient'][:30] + "..." if len(email['recipient']) > 30 else email['recipient'],
                    'Date': email['date'],
                    'Type': email_type
                })
            
            df_display = pd.DataFrame(email_display_data)
            
            # ===== MULTI-SELECT DATA EDITOR (NEW FEATURE) =====
            st.markdown("**Select one or more emails to extract:**")
            
            edited_df = st.data_editor(
                df_display,
                column_config={
                    "Select": st.column_config.CheckboxColumn(
                        "Select",
                        help="Select emails for extraction",
                        default=False,
                    )
                },
                disabled=["Index", "Trade ID", "Subject", "From", "To", "Date", "Type"],
                hide_index=True,
                use_container_width=True,
                key='email_selector'
            )
            
            # Update selected emails based on checkboxes
            st.session_state.selected_emails = edited_df[edited_df['Select'] == True]['Index'].tolist()
            
            # Show selection summary
            if st.session_state.selected_emails:
                st.info(f"‚úÖ Selected {len(st.session_state.selected_emails)} email(s) for extraction")
                
                # Quick actions
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    if st.button("‚úÖ Select All", use_container_width=True):
                        df_display['Select'] = True
                        st.rerun()
                
                with col2:
                    if st.button("‚ùå Deselect All", use_container_width=True):
                        st.session_state.selected_emails = []
                        st.rerun()
                
                with col3:
                    if st.button("üîÑ Invert Selection", use_container_width=True):
                        df_display['Select'] = ~df_display['Select']
                        st.rerun()
            
            # Email preview
            if st.session_state.selected_emails:
                with st.expander("üëÅÔ∏è Preview Selected Emails"):
                    for idx in st.session_state.selected_emails[:3]:  # Show first 3
                        email = st.session_state.emails[idx]
                        st.markdown(f"**{idx+1}. {email['subject']}**")
                        st.text(f"From: {email['sender']} | Date: {email['date']}")
                        st.text(email['body'][:200] + "...")
                        st.markdown("---")
                    
                    if len(st.session_state.selected_emails) > 3:
                        st.info(f"... and {len(st.session_state.selected_emails) - 3} more")
        else:
            st.info("‚ÑπÔ∏è No emails loaded. Fetch emails first.")
    
    # ========== TAB 2: EXTRACT & EXPORT ==========
    with tab2:
        st.header("üîç Extract & Export")
        
        if not st.session_state.selected_emails:
            st.warning("‚ö†Ô∏è Please select emails from 'Fetch Emails' tab first")
        else:
            # Show selected emails summary
            st.info(f"üìß {len(st.session_state.selected_emails)} email(s) selected for extraction")
            
            # Extract button
            col1, col2, col3 = st.columns([1, 2, 1])
            
            with col2:
                if st.button("üöÄ Extract Entities from Selected Emails", type="primary", use_container_width=True):
                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    
                    all_results = []
                    
                    for idx, email_idx in enumerate(st.session_state.selected_emails):
                        email_data = st.session_state.emails[email_idx]
                        
                        status_text.text(f"Processing email {idx+1}/{len(st.session_state.selected_emails)}: {email_data['subject'][:50]}...")
                        
                        # Call your existing extract_and_export function
                        result = extraction_backend.extract_and_export(
                            email_data,
                            st.session_state.entity_definitions
                        )
                        
                        if result['success']:
                            all_results.append({
                                'email_idx': email_idx,
                                'trade_id': email_data['trade_id'],
                                'result': result
                            })
                        
                        progress_bar.progress((idx + 1) / len(st.session_state.selected_emails))
                    
                    st.session_state.extraction_results = all_results
                    status_text.empty()
                    progress_bar.empty()
                    
                    st.success(f"‚úÖ Extraction complete! Processed {len(all_results)} emails")
                    st.balloons()
            
            # Display extraction results
            if st.session_state.extraction_results:
                st.markdown("---")
                st.subheader("üìä Extraction Results")
                
                # Summary metrics
                total_records = sum(r['result']['records'] for r in st.session_state.extraction_results)
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("üìù Total Records", total_records)
                with col2:
                    st.metric("üìß Emails Processed", len(st.session_state.extraction_results))
                with col3:
                    avg_records = total_records / len(st.session_state.extraction_results) if st.session_state.extraction_results else 0
                    st.metric("üìä Avg Records/Email", f"{avg_records:.1f}")
                with col4:
                    st.metric("‚úÖ Success Rate", "100%")
                
                # Results per email
                for result_data in st.session_state.extraction_results:
                    email_idx = result_data['email_idx']
                    trade_id = result_data['trade_id']
                    result = result_data['result']
                    
                    with st.expander(f"üìß {trade_id} - {result['records']} records"):
                        if not result['dataframe'].empty:
                            st.dataframe(result['dataframe'], use_container_width=True)
                            
                            # Download button for individual email
                            csv = result['dataframe'].to_csv(index=False).encode('utf-8')
                            st.download_button(
                                label=f"üì• Download CSV for {trade_id}",
                                data=csv,
                                file_name=f"{trade_id}_extraction.csv",
                                mime="text/csv",
                                key=f"download_{email_idx}"
                            )
                        else:
                            st.info("No records extracted")
    
    # ========== TAB 3: CONSOLIDATED RESULTS ==========
    with tab3:
        st.header("üìä Consolidated Results")
        
        # Consolidate button
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col2:
            if st.button("üìä Generate Consolidated Report", type="primary", use_container_width=True):
                with st.spinner("üîÑ Consolidating results..."):
                    result = extraction_backend.export_consolidated_results()
                
                if result['success']:
                    st.session_state.consolidated_file = result['file']
                    st.success(f"‚úÖ Consolidated {result['records']} records!")
                    
                    # Show download button
                    if os.path.exists(result['file']):
                        with open(result['file'], 'rb') as f:
                            st.download_button(
                                label="üì• Download Consolidated Excel",
                                data=f,
                                file_name=os.path.basename(result['file']),
                                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                                use_container_width=True
                            )
                else:
                    st.error(f"‚ùå Consolidation failed: {result['error']}")
        
        # Show consolidated file info
        if st.session_state.consolidated_file:
            st.markdown("---")
            st.info(f"üìÅ Last consolidated file: {st.session_state.consolidated_file}")
    
    # ========== TAB 4: ANALYTICS ==========
    with tab4:
        st.header("üìà Analytics & Statistics")
        
        if st.session_state.extraction_results:
            # Overall statistics
            all_dfs = [r['result']['dataframe'] for r in st.session_state.extraction_results 
                      if not r['result']['dataframe'].empty]
            
            if all_dfs:
                combined_df = pd.concat(all_dfs, ignore_index=True)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üìä Extraction Methods")
                    if 'Extraction_Method' in combined_df.columns:
                        method_counts = combined_df['Extraction_Method'].value_counts()
                        st.bar_chart(method_counts)
                
                with col2:
                    st.subheader("üìß Records by Email")
                    email_counts = combined_df.groupby('Trade_ID').size()
                    st.bar_chart(email_counts)
            else:
                st.info("‚ÑπÔ∏è No data to visualize")
        else:
            st.info("‚ÑπÔ∏è Extract entities first to see analytics")


# ============================================================================
# RUN APP
# ============================================================================

if __name__ == "__main__":
    main()
